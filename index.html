<html>
    <head>
        <script src="three.js"></script>
    </head>
<body>
    <canvas id="mainCanvas" style="display: none;" width="3200" height="3200">

    </canvas>

    <script>
        function buildGeometryForWallSection(geometry, faceIndex, v0x, v0y, bottom, v1x, v1y, top) {
            geometry.vertices.push(new THREE.Vector3(v0x, bottom, -v0y));
            geometry.vertices.push(new THREE.Vector3(v1x, bottom, -v1y));
            geometry.vertices.push(new THREE.Vector3(v1x, top, -v1y));
            geometry.vertices.push(new THREE.Vector3(v1x, top, -v1y));
            geometry.vertices.push(new THREE.Vector3(v0x, top, -v0y));
            geometry.vertices.push(new THREE.Vector3(v0x, bottom, -v0y));

            var normal = new THREE.Vector3(0, 0, 1);
            var color = new THREE.Color(Math.floor(Math.random() * 256) * 256);
            var materialIndex = 0;
            geometry.faces.push(new THREE.Face3(faceIndex * 6 + 0, faceIndex * 6 + 1, faceIndex * 6 + 2, normal, color, materialIndex));

            var normal = new THREE.Vector3(0, 0, 1);
            var materialIndex = 0;
            geometry.faces.push(new THREE.Face3(faceIndex * 6 + 3, faceIndex * 6 + 4, faceIndex * 6 + 5, normal, color, materialIndex));
        }

        function buildGeometry(wad) {
            geometry = new THREE.Geometry();

            var map01LumpInfo = wad.getFirstMatchingLumpAfterSpecifiedLumpIndex("MAP01", 0);
            var lineDefsLumpInfo = wad.getFirstMatchingLumpAfterSpecifiedLumpIndex("LINEDEFS", map01LumpInfo.lumpIndex);
            var vertexesLumpInfo = wad.getFirstMatchingLumpAfterSpecifiedLumpIndex("VERTEXES", map01LumpInfo.lumpIndex);
            var sidedefsLumpInfo = wad.getFirstMatchingLumpAfterSpecifiedLumpIndex("SIDEDEFS", map01LumpInfo.lumpIndex);
            var sectorsLumpInfo = wad.getFirstMatchingLumpAfterSpecifiedLumpIndex("SECTORS", map01LumpInfo.lumpIndex);

            var numberOfLineDefs = lineDefsLumpInfo.length / 14;

            var faceIndex = 0;

            for (var i = 0; i < numberOfLineDefs; i++) {
                var rightSideDefIndex = wad.readInt16At(lineDefsLumpInfo.offset + (i * 14) + 10);
                var leftSideDefIndex = wad.readInt16At(lineDefsLumpInfo.offset + (i * 14) + 12);

                var rightSectorIndex = wad.readInt16At(sidedefsLumpInfo.offset + rightSideDefIndex * 30 + 28);
                var frontSectorFloorHeight = wad.readInt16At(sectorsLumpInfo.offset + rightSectorIndex * 26 + 0);
                var frontSectorCeilingHeight = wad.readInt16At(sectorsLumpInfo.offset + rightSectorIndex * 26 + 2);

                var vi0 = wad.readInt16At(lineDefsLumpInfo.offset + (i * 14));
                var vi1 = wad.readInt16At(lineDefsLumpInfo.offset + (i * 14) + 2);

                var v0x = wad.readInt16At(vertexesLumpInfo.offset + (vi0 * 4));
                var v0y = wad.readInt16At(vertexesLumpInfo.offset + (vi0 * 4) + 2);
                var v1x = wad.readInt16At(vertexesLumpInfo.offset + (vi1 * 4));
                var v1y = wad.readInt16At(vertexesLumpInfo.offset + (vi1 * 4) + 2);

                var frontTopTexture = wad.readStringAt(sidedefsLumpInfo.offset + rightSideDefIndex * 30 + 4);
                var frontBottomTexture = wad.readStringAt(sidedefsLumpInfo.offset + rightSideDefIndex * 30 + 12);
                var frontMiddleTexture = wad.readStringAt(sidedefsLumpInfo.offset + rightSideDefIndex * 30 + 20);
                
                // If this is a one-sided wall
                if (leftSideDefIndex == -1) {
                    if (frontMiddleTexture != '-') {
                        buildGeometryForWallSection(geometry, faceIndex++, v0x, v0y, frontSectorFloorHeight, v1x, v1y, frontSectorCeilingHeight);
                    }
                } else {
                    // This is a two-sided wall - read the far-side's details
                    var leftSectorIndex = wad.readInt16At(sidedefsLumpInfo.offset + leftSideDefIndex * 30 + 28);
                    var backSectorFloorHeight = wad.readInt16At(sectorsLumpInfo.offset + leftSectorIndex * 26 + 0);
                    var backSectorCeilingHeight = wad.readInt16At(sectorsLumpInfo.offset + leftSectorIndex * 26 + 2);

                    var backTopTexture = wad.readStringAt(sidedefsLumpInfo.offset + leftSideDefIndex * 30 + 4);
                    var backBottomTexture = wad.readStringAt(sidedefsLumpInfo.offset + leftSideDefIndex * 30 + 12);
                    var backMiddleTexture = wad.readStringAt(sidedefsLumpInfo.offset + leftSideDefIndex * 30 + 20);

                    // Bottom section of front side
                    if (frontBottomTexture != '-' && frontSectorFloorHeight != backSectorFloorHeight) {
                        buildGeometryForWallSection(geometry, faceIndex, v0x, v0y, frontSectorFloorHeight, v1x, v1y, backSectorFloorHeight);
                        faceIndex++;
                    }

                    // Top section of front side
                    if (frontTopTexture != '-' && backSectorCeilingHeight != frontSectorCeilingHeight) {
                        buildGeometryForWallSection(geometry, faceIndex, v0x, v0y, backSectorCeilingHeight, v1x, v1y, frontSectorCeilingHeight);
                        faceIndex++;
                    }

                    // Bottom section of back side
                    if (backBottomTexture != '-' && frontSectorFloorHeight != backSectorFloorHeight) {
                        buildGeometryForWallSection(geometry, faceIndex, v1x, v1y, backSectorFloorHeight, v0x, v0y, frontSectorFloorHeight);
                        faceIndex++;
                    }

                    // Top section of back side
                    if (backTopTexture != '-' && backSectorCeilingHeight != frontSectorCeilingHeight) {
                        buildGeometryForWallSection(geometry, faceIndex, v1x, v1y, frontSectorCeilingHeight, v0x, v0y, backSectorCeilingHeight);
                        faceIndex++;
                    }
                }
            }
            
            geometry.computeFaceNormals();
            geometry.computeVertexNormals();

            return geometry;
        }

        function renderToThreeJs(wad) {
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 20000 );

            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lights
            var light = new THREE.AmbientLight(0x404040);
            scene.add(light);

            // White directional light at half intensity
            var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.x = 1;
            directionalLight.position.y = 1;
            directionalLight.position.z = 1;

            scene.add(directionalLight);

            var material = new THREE.MeshBasicMaterial({
                wireframe: false,
                vertexColors: THREE.FaceColors
            });

            geometry = buildGeometry(wad);

            scene.add(new THREE.Mesh(geometry, material));

            camera.position.y = 1000;
            camera.position.z = 500;
            camera.rotation.x = -0.75;
            camera.rotation.y = -0.2;

            var time = 0;
            function animate() {
                time += 0.01;

                camera.position.x = -200 + Math.sin(time * 0.6) * 1200;
                camera.position.y = 1000 + Math.sin(time * 0.5) * 800;
                camera.rotation.y = -0.2 + Math.sin(time) * 0.1;

                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }

            animate();
        }

        function loadWad() {
            var myRequest = new Request('doom2.wad');

            var wad = {
                bytes: null,
                NumLumps: null,
                DirectoryOffset: null
            };

            function readInt32At(offset) {
                var val =
                    (wad.bytes[offset    ] << 0) + 
                    (wad.bytes[offset + 1] << 8) +
                    (wad.bytes[offset + 2] << 16) +
                    (wad.bytes[offset + 3] << 24);

                return val;
            }

            
            function readInt16At(offset) {
                var val =
                    (wad.bytes[offset    ] << 0) + 
                    (wad.bytes[offset + 1] << 8);

                if (val > 32767) {
                    val = -65536 + val;
                }

                return val;
            }

            function readStringAt(offset, maxLength) {
                var s = "";

                var i = 0;

                do {
                    var b = wad.bytes[offset + i];

                    if (b) {
                        s += String.fromCharCode(b);
                    }

                    i++;
                } while (i < maxLength);

                return s;
            }

            function getFirstMatchingLumpAfterSpecifiedLumpIndex(name, startIndex) {
                for (var i = startIndex; i < wad.NumLumps; i++) {
                    var directoryEntryOffset = wad.DirectoryOffset + i * 16;
                    
                    var lumpName = readStringAt(directoryEntryOffset + 8, 8);

                    if (lumpName == name) {
                        return {
                            offset: readInt32At(directoryEntryOffset),
                            length: readInt32At(directoryEntryOffset + 4),
                            name: name,
                            lumpIndex: i
                        };
                    }
                }
            }

            return (
                fetch(myRequest)
                .then(response => response.blob())
                .then(blob => blob.arrayBuffer())
                .then(arrayBuffer => {
                    wad.bytes = new Uint8Array(arrayBuffer);

                    wad.NumLumps = readInt32At(4);
                    wad.DirectoryOffset = readInt32At(8);

                    wad.getFirstMatchingLumpAfterSpecifiedLumpIndex = getFirstMatchingLumpAfterSpecifiedLumpIndex;
                    wad.readInt16At = readInt16At;
                    wad.readInt32At = readInt32At;
                    wad.readStringAt = readStringAt;

                    return wad;
                })
            );
        }

        function render2dMapToCanvas(wad) {
            var canvas = document.getElementById('mainCanvas');

            canvas.style.display = "inline-block";

            var ctx = canvas.getContext('2d');

            var map01LumpInfo =    wad.getFirstMatchingLumpAfterSpecifiedLumpIndex("MAP01", 0);
            var lineDefsLumpInfo = wad.getFirstMatchingLumpAfterSpecifiedLumpIndex("LINEDEFS", map01LumpInfo.lumpIndex);
            var vertexesLumpInfo = wad.getFirstMatchingLumpAfterSpecifiedLumpIndex("VERTEXES", map01LumpInfo.lumpIndex);

            var scaleFactor = 0.25;
            var xOffset = 400;
            var yOffset = 800;

            var numberOfLineDefs = lineDefsLumpInfo.length / 14;

            for (var i = 0; i < numberOfLineDefs; i++) {
                var vi0 = wad.readInt16At(lineDefsLumpInfo.offset + (i * 14));
                var vi1 = wad.readInt16At(lineDefsLumpInfo.offset + (i * 14) + 2);

                var v0x = wad.readInt16At(vertexesLumpInfo.offset + (vi0 * 4));
                var v0y = wad.readInt16At(vertexesLumpInfo.offset + (vi0 * 4) + 2);
                var v1x = wad.readInt16At(vertexesLumpInfo.offset + (vi1 * 4));
                var v1y = wad.readInt16At(vertexesLumpInfo.offset + (vi1 * 4) + 2);

                ctx.beginPath();
                ctx.moveTo(v0x * scaleFactor + xOffset, v0y * -scaleFactor + yOffset);
                ctx.lineTo(v1x * scaleFactor + xOffset, v1y * -scaleFactor + yOffset);
                ctx.stroke();
            }
        }

        //loadWad().then(render2dMapToCanvas);
        loadWad().then(renderToThreeJs);
    </script>
</body>
</html>